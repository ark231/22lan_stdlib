#defmacro ifz dst
    \autopushltor0 l{#{dst}}
    ifz
#endmacro

#defmacro goto dst
    \call clr0
    xchg03
    xchg13
    xchg03
    \autopushltor0 l{#{dst}}
    ifz
#endmacro

#defmacro xchg dst, src
    xchg#{dst}3
    xchg#{src}3
    xchg#{dst}3
#endmacro

;\autofunc std
;\@nand s0_64, s0_64 -> s0_64
startfunc
    \call pop64s0
    xchg03
    xchg13
    \call pop64s0
    nand
    \call push64r2tos0
    @{nand}
endfunc

;\autofunc std
;\@not s0_64 -> s0_64
;\r0: invalidated, r1: invalidated, r2: invalidated
startfunc
    \call dup64s0
    \call pop64s0
    xchg03
    xchg13
    xchg03
    \call pop64s0
    ;`a nand a` is equivalent to `not a`
    nand
    \call push64r2tos0
    @{not}
endfunc

;\autofunc std
;\@and s0_64, s0_64 -> s0_64
startfunc
    \call pop64s0
    xchg03
    xchg13
    \call pop64s0
    nand
    \call push64r2tos0
    \call not
    @{and}
endfunc

;\autofunc std
;\@or s0_64, s0_64 -> s0_64
startfunc
    ;`not ((not a) and (not b))` is equivalent to `a or b`
    \call not
    \call pop64s0
    xchg03
    xchg13
    \call push64s1
    \call not
    \call pop64s1
    xchg13
    xchg23
    \call push64r2tos0
    \call and
    \call not
    @{or}
endfunc

;\autofunc std
;\@xor s0_64, s0_64 -> s0_64
startfunc
    ;`(a or b) and (a nand b)` is equivalent to `a xor b`
    \call dup128s0
    \call or
    \call pop64s0
    xchg03
    xchg13
    \call push64s1
    \call nand
    \call pop64s1
    xchg13
    xchg03
    \call and
    @{xor}
endfunc

;\autofunc std
;\@add s0_64, s0_64 -> s0_64
startfunc
    ;二番目の引数をr1に格納
    \call pop64s0
    xchg03
    xchg13
    \call push64s1
    \call pop64s0
    xchg03
    xchg23
    \call push64s2
    \call pop64s1
    xchg13
    xchg23
    \call push64r2tos0
    \call pop64s2
    xchg23
    xchg13

    \autopushltor0 l{end}
    ifz

    ;r1にある2番めの引数をスタックの二番目に戻す
    \call push64s1
    \call pop64s0
    xchg03
    xchg23
    \call push64s2
    \call pop64s1
    xchg13
    xchg23
    \call push64r2tos0
    \call pop64s2
    \call push64r2tos0
    
    ;add((arg0 xor arg1) , (arg0 and arg1) << 1)
    \call dup128s0
    \call xor
    \call pop64s0
    xchg03
    xchg23
    \call push64s2
    \call and
    \call pop64s0
    xchg03
    xchg13
    xchg03
    one
    pushl8
    pop8s0
    xchg03
    xchg13
    xchg03
    lshift
    \call push64r2tos0
    \call pop64s2
    \call push64r2tos0
    \call add

    \autolabel end
    @{add}
endfunc

;\autofunc std
;\@sub s0_64, s0_64 -> s0_64
startfunc
    ;一番目の引数を退避
    \call pop64s0
    xchg03
    xchg23
    \call push64s2
    
    ;二番目の引数を2の補数に変換する
    \call not
    \call clr0
    one
    pushl8
    pop8s0
    xchg03
    xchg23
    \call push64r2tos0
    \call add

    ;一番目の引数を戻す
    \call pop64s2
    \call push64r2tos0

    ;add(arg0 , add(1 , not arg1))
    \call add
    @{sub}
endfunc

;\autofunc std
;\@dup64s0 s0_64 -> s0_64, s0_64
startfunc

    ;load 0b1000'0000 to r2
    \pushl8 0b1000_0000
    pop8s0
    xchg03
    xchg23
    xchg03

    ;load 0b1111'1111 (ie. -1) to r1
    \pushl8 -1
    pop8s0
    xchg03
    xchg13
    xchg03

    ;save -1 into s1 (ループ処理部との整合性のため)
    push8s1

    ;label 0
    deflabel

    ;restore -1 from s1
    pop8s1

    ;duplicate top byte of s0 into s1 and s2
    pop8s0
    ;xchg01
    xchg03
    xchg13
    xchg03
    push8s1
    ;xchg12
    xchg13
    xchg23
    xchg13
    push8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23

    ;rshift counter 1bit and if it is zero, jump to label 1
    ;now, r0 is free, r1 is -1, r2 is counter
    ;exchange r0 and r2
    xchg03
    xchg23
    xchg03
    ;now, r0 is counter, r1 is -1, r2 is free

    lshift
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    ;now, r0 is free, r1 is counter, r2 is -1

    one
    pushl8
    pop8s0
    ifz

    xchg13
    xchg23
    xchg13
    ;now, r0 is free, r1 is -1, r2 is counter

    ;save r1_8 into s1
    push8s1

    ;goto label 1
    pushl8
    pop8s0
    ;xchg12
    xchg13
    xchg23
    xchg13
    pushl8
    pop8s0
    ifz

    ;label 1
    one
    deflabel
    ;now, r0 is free, r1 is 0, r2 is -1
    ;now, all register becomes free

    ;move s1_64 to s0
    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    pop8s1
    xchg03
    xchg13
    xchg03
    push8s0

    ;move s2_64 to s0
    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    pop8s2
    ;r2->r0,r0->r1,r1->r2
    xchg23
    xchg03
    xchg13
    xchg23
    push8s0

    @{dup64s0}
endfunc

;\autofunc std
;\@dup128s0 s0_128 -> s0_128, s0_128
startfunc
    \call pop64s0
    xchg03
    xchg23
    xchg03
    \call push64s2
    \call dup64s0
    \call pop64s2
    \call push64r2tos0
    \call dup64s0
    @{dup128s0}
endfunc

;\autofunc std
;\@isp s0_64 -> s0_8
startfunc
    \call pop64s0
    xchg13
    xchg03
    xchg13
    #ifz false

    xchg13
    xchg03
    xchg13
    \pushl8 -63
    xchg13
    xchg03
    pop8s0
    xchg03
    xchg13
    lshift
    xchg13
    xchg23
    xchg13
    #ifz true

    \autolabel false
        \pushl8 0
        #goto end
    \autolabel true
        \pushl8 1

    \autolabel end
    @{isp}
endfunc

;\autofunc std
;\@isn s0_64 -> s0_8
startfunc
    \call dup64s0
    \call pop64s0
    xchg03
    xchg13
    xchg03
    #ifz false
        \call isp
        \call bool_not
        #goto end
    \autolabel false
        \pushl8 0
    \autolabel end
    @{isn}
endfunc

;\autofunc std
;\@clr0 none -> r0_64
startfunc
    ;save r1_8 into s1
    push8s1
    ;load 0b100'0000 (ie. 64) to r1
    one
    zero
    zero
    zero
    pushl8
    xchg03
    xchg13
    xchg03
    pop8s0
    xchg03
    xchg13
    xchg03

    lshift
    xchg23
    xchg03

    @{clr0}
endfunc

;\autofunc std
;\@pop64s0 s0_64 -> r0_64
;\r0: result, r1: const, r2: invalidated
startfunc
    ;save r1_8 into s1
    push8s1

    \pushl8 8
    xchg03
    xchg13
    xchg03
    pop8s0
    xchg03
    xchg13
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0
    lshift
    xchg23
    xchg03

    pop8s0

    ;restore r1_8 from s1
    pop8s1

    @{pop64s0}
endfunc

;\autofunc std
;\@pop64s1 s1_64 -> r1_64
startfunc
    ;load 8 to r1_8
    \pushl8 8
    pop8s0
    xchg03
    xchg13

    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    xchg13
    xchg03
    lshift

    xchg23
    xchg13
    pop8s1
    @{pop64s1}
endfunc

;\autofunc std
;\@pop64s2 s2_64 -> r2_64
startfunc
    ;load 8 to r1_8
    \pushl8 8
    pop8s0
    xchg03
    xchg13

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    xchg23
    xchg03
    lshift

    pop8s2
    @{pop64s2}
endfunc

;\autofunc std
;\@push64r2tos0 r2_64 -> s0_64 
;\r0: invalidated, r1: const, r2: invalidated
startfunc

    ;save r1_8 into s1
    push8s1

    \pushl8 -8
    #xchg 0,1
    pop8s0
    #xchg 0,1

    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0
    lshift
    xchg23
    xchg03

    push8s0

    ;restore r1_8 from s1
    pop8s1

    @{push64r2tos0}
endfunc

;\autofunc std
;\@push64s1 r1_64 -> s1_64
startfunc
    push8s1
    \pushl8 -8
    pop8s0
    #xchg 0,1

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    lshift
    #xchg 1,2
    push8s1
    #xchg 0,1
    #xchg 1,2

    @{push64s1}
endfunc

;\autofunc std
;\@push64s2 r2_64 -> s2_64
startfunc
    push8s2
    \pushl8 -8
    pop8s0
    #xchg 0,1
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    lshift
    push8s2
    #xchg 0,2

    @{push64s2}
endfunc

;\autofunc std
;\@ext8to64s0 s0_8 -> s0_64
startfunc
    pushl8
    pushl8
    pushl8
    pushl8
    pushl8
    pushl8
    pushl8
    @{ext8to64s0}
endfunc

;\autofunc std
;\@bool_not s0_8 -> s0_8
startfunc
    \call clr0
    pop8s0
    xchg03
    xchg13
    xchg03
    #ifz true
        ;false
        \pushl8 0
        pushl8
        #goto end
    \autolabel true
        \pushl8 0
        pushl8
    \autolabel end
    @{bool_not}
endfunc

;\autofunc std
;\@bool_and s0_8, s0_8 -> s0_8
startfunc
    pop8s0
    #xchg 0,1
    push8s1
    \call ext8to64s0
    pop8s1
    #xchg 0,1
    push8s0
    \call ext8to64s0
    \call and
    \call to_bool
    @{bool_and}
endfunc

;\autofunc std
;\@bool_or s0_8, s0_8 -> s0_8
startfunc
    pop8s0
    #xchg 0,1
    push8s1
    \call ext8to64s0
    pop8s1
    #xchg 0,1
    push8s0
    \call ext8to64s0
    \call or
    \call to_bool
    @{bool_or}
endfunc

;\autofunc std
;\@bool_xor s0_8, s0_8 -> s0_8
startfunc
    pop8s0
    #xchg 0,1
    push8s1
    \call ext8to64s0
    pop8s1
    #xchg 0,1
    push8s0
    \call ext8to64s0
    \call xor
    \call to_bool
    @{bool_xor}
endfunc

;\autofunc std
;\@to_bool s0_64 -> s0_8
startfunc
    \call pop64s0
    #xchg 0,1
    #ifz false
        \pushl8 1
        #goto end
    \autolabel false
        \pushl8 0
    \autolabel end
    @{to_bool}
endfunc
